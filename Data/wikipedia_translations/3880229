Shift-azaltmak ayrıştırıcı
Bir shift-azaltmak ayrıştırıcı resmen bir gramer ile tanımlanan bilgisayar dilleri ve diğer gösterimler için verimli, masa odaklı aşağıdan yukarıya ayrıştırma yöntemleri bir sınıftır. En yaygın bugün, LR ayrıştırma ve çeşitleri kullanılan ayrıştırma yöntemleri, shift-azaltmak yöntemlerdir. LR ayrıştırma icadından önce kullanılan öncelik ayrıştırıcıları da-shift azaltmak yöntemlerdir. Tüm shift-azaltmak ayrıştırıcıları onlar spesifik çıkış eylemleri bir ayrıştırma ağacı oluşturmak veya çağrı hangi artan sırayla benzer dışa etkileri vardır. Bir LR çözümleyici dışa eylemleri en sadece bazı genel shift-azaltmak yöntemi olarak çözümleyici bakarak yerine LR ayrıştırıcı tabloları oluşturulur nasıl gizemli matematiksel ayrıntıları göz ardı ederek, tarafından anlaşılmaktadır.
Örnek A = B + C * 2 için Ağacı ayrıştırın.
Bir ayrıştırıcı taramaları shift-azaltmak ve yedekleme olmadan tek ileriye giriş metin metin üzerinden geçmek ayrıştırır. (Yani ileri yön genellikle bir çizgi içinde sağa-sola edilir ve üst-to-alt çok satırlı girişleri için.) Çözümleyici kademeli ayrıştırma ağacı kurar, aşağıdan yukarıya ve tahmin veya Backtracking olmadan, soldan sağa doğru. Bu geçişte her noktada, çözümleyici alt ağaçlar ya da zaten çözümlenen olan giriş metninin cümleleri bir listesini birikmiş. Ayrıştırıcı henüz bunları bir araya getirecektir sözdizimi desen sağ ucunu ulaşamamıştır çünkü bu alt ağaçlar henüz bir araya değildir.
Örneğin adım 7 ayrıştırmak anda, sadece "A = B +" ayrıştırıldı olmuştur. Sadece Çözümleme ağacının gölgeli sol alt köşesi var. Yukarıda 8 numaralı ve ayrıştırma ağaç düğümleri hiçbiri henüz mevcut. Düğümler 1, 2, 6, 7 ve tüm öğeleri 1..7 kapsayan izole alt ağaçlar kökleri vardır. Düğüm düğüm 1 6 summand B ve düğüm 7 operatör + değişkendir, A, düğüm 2 ayraç = olmasıdır. Bu dört kök düğümleri geçici bir ayrıştırma yığınına tutulur. giriş akışı kalan çözümlenmemiş kısmı "C * 2" dir.
Bir Vardiya bazı adımlar kombinasyonu yaparak ayrıştırıcı işleri shift-azaltmak ve adımları, adından azaltın.
girdi tüm tüketilen edilmiş ve ayrıştırma ağaçları tüm tüm yasal girişini simgeleyen bir tek ağaca düşürülmüştür kadar ayrıştırıcı adımları ile devam ediyor.
Örnek A = B + C * 2 Adımlar Parse.
Her ayrıştırmak adımda, tüm giriş metin ayrıştırmak yığının mevcut ileri yönlü sembolü ve kalan Taranmamış metne ayrılmıştır. çözümleyici sonraki eylem sağdaki yığın sembolü (ler) ve ileri yönlü sembolü tarafından belirlenir. Eylem yığını ve ileri yönlü sembolleri tüm sözdizimsel geçerli kombinasyonlarını içeren bir tablodan okunur.
Daha basit bir örnek için bkz.
Örnek Dilbilgisi.
Bir gramer giriş dili için desen veya sözdizimi kuralları kümesidir. Bu tür numaraların büyüklüğü veya tüm programı bağlamında isimleri ve tanımları tutarlı kullanımı gibi tüm dil kurallarını kapsamaz. Shift-azaltmak ayrıştırıcıları sadece semboller yerel desenleri ile uğraşan bir bağlam serbest dilbilgisi kullanın.
Burada kullanılan örnek dilbilgisi Java ya da C dilinde küçük bir alt kümesidir:
gramer terminal semboller sözlü tarayıcı tarafından giriş akışı bulunan çoklu karakter sembolleri ya da 'belirteçleri' vardır. İşte bu = + * ve herhangi bir tanımlayıcı isim için herhangi bir tamsayı sabiti "int" ve "id" yer alıyor. dilbilgisi "int" değerler veya "id" yazımlar ne umursamıyor, ne de boşlukları veya satır sonları umurumda değil. dilbilgisi, bu uç sembolleri kullanır ancak bunları tanımlamaz. Onlar Çözümleme ağacının alt gür ucunda her zaman vardır.
Toplamlar gibi büyük harfli terimler nonterminal sembollerdir. Bunlar dilde kavram ya da desenler adlarıdır. Bunlar dilbilgisi tanımlanan ve giriş akışı kendilerini ortaya asla. Onlar Çözümleme ağacının dibine üstünde her zaman vardır. Onlar sadece bazı dilbilgisi kuralı uygulayarak çözümleyici bir sonucu olarak gerçekleşir. Bazı terminaller iki veya daha fazla kurallara tanımlanır; Bu alternatif modeller vardır. Kurallar kendilerini geri başvurabilirsiniz. Bu dilbilgisi tekrarlanan matematik operatörleri işlemek için özyinelemeli kuralları kullanır. Tam diller için Gramerleri listeleri, parantez ifadeleri ve iç içe ifadeleri işlemek için özyinelemeli kuralları kullanabilirsiniz.
Herhangi Verilen bilgisayar dili farklı gramerler tarafından tarif edilebilir. Bir shift-azaltmak çözümleyici için dilbilgisi kesin kendisi olmalı, ya da kravat kıran öncelik kurallarına göre artırılabilir. Bu / O, örneğin eylemleri azaltmak eşsiz bir ayrıştırma ağacı ve vardiya eşsiz bir sırayla sonuçlanan, dilin belirli bir yasal örnek dilbilgisi uygulamak için tek bir doğru yolu var demektir.
Bir tablo odaklı ayrıştırıcı ayrıştırıcı tabloları denilen değişmeyen veri içine kodlanmış gramer konusundaki tüm bilgi vardır. çözümleyici program kodu, birçok gramerler ve diller için geçerli değişmeden basit bir jenerik döngü. tablolar önceliği yöntemleri için elle dışarı çalıştı olabilir. LR yöntemleri için, karmaşık tablolar mekanik Bison gibi bazı ayrıştırıcı jeneratör aracı tarafından bir dilbilgisi türetilmiştir. Ayrıştırıcı tabloları genellikle gramer çok daha büyüktür. Böyle özyinelemeli kökenli olarak tablo odaklı olmayan diğer ayrıştırıcıları,, her dil oluşumu bu bir yapının sözdizimi uzmanlaşmış, farklı bir alt yordam tarafından ayrıştırılır.
Ayrıştırıcı Eylemleri.
shift-azaltmak çözümleyici verimliliği hiçbir yedekleme veya geriye gidilmiştir yapıyor değil. Onun toplam süre girdi uzunluğu ve tam ayrıştırma ağacının büyüklüğü ile doğrusal olarak ölçekler. Onlar kötü tahmin zaman N2 veya N3 zaman alabilir sarfınazar diğer ayrıştırıcı yöntemleri.
Tahmin önlemek için, shift-azaltmak ayrıştırıcı genellikle önceden taranmış sembolleri ile ne yapacağınıza karar vermeden önce, önde (sağa) aşağıdaki taranan sembol bakar. sözcük tarayıcı, bir sembol öncesinde çözümleyici geri kalanı çalışır. ileri yönlü sembolü, her ayrıştırma kararı için 'sağ bağlam "dir. (En pratik dilbilgisi bir ileri yönlü simge kullanımı için tasarlanmış olabilir, ancak nadiren, iki veya daha fazla ileri yönlü semboller de kullanılabilir.)
O taranır ve kombine yapı nedir işlemeden önce bazı yapının tüm parçaları ayrıştırıldı kadar bir kayma-azaltmak ayrıştırıcı bekler. Çözümleyici sonra yerine başka herhangi bir bekleme kombinasyonu hemen etki eder. Yukarıdaki ayrıştırma ağacı örnekte, ifade B 3-6 kısa sürede lookahead + görüldüğü gibi herhangi bir bekleme yerine daha sonra Çözümleme ağacının bu parçaların organize adımda Ürünleri ve Toplamlar sonra değer düşürülür ve olur. B işlemek için nasıl kararlar daha sonra sağında görünür şeyler dikkate almadan, sadece ayrıştırıcı ve tarayıcı zaten gördüklerimi dayanmaktadır.
İndirimler hemen ileri yönlü sembolü solunda, en son çözümlenen şeyler yeniden. Yani zaten çözümlenen şeylerin listesini bir yığın gibi davranır. Bu ayrıştırma yığını sağa büyür. yığının tabanı veya alt solda ve en soldaki, en eski ayrıştırma fragmanı tutar. Her indirgeme adım sadece en sağdaki, en yeni ayrıştırma parçaları üzerinde hareket eder. (Bu birikmiş ayrıştırma yığını çok yukarıdan aşağıya ayrıştırıcıları tarafından kullanılan akıllı, sola büyüyen ayrıştırma yığınının benzemez.)
Ne zaman bir dilbilgisi kuralı gibi
uygulanır yığın üst ayrıştırmak ağaçları ... "Ürünler * Value" tutar. Kuralın sağ tarafta bu Bulunan örnek tanıtıcı denir. azaltmak adım kolu burada, nonterminal sol taraftaki tarafından büyük Ürünler "Ürünler değer *" yerine geçer. Ayrıştırıcı tam ayrıştırmak ağaçları oluşturur, iç Ürünleri, *, ve Değer üç ağaç ürünleri için yeni bir ağaç kökü ile birleştirilir. Aksi takdirde, iç Ürünler ve Değeri anlamsal ayrıntıları daha sonra bazı derleyici geçmek çıktı, ya da kombine ve yeni ürünler sembol kaydedilir.
ayrıştırıcı sürece orada gramer kurallarının yeni tamamlanan örnekler bulmak tutar olarak ayrıştırmak için yığının üstüne indirim uygulayarak tutar. Daha fazla kural uygulanabilir zaman ayrıştırıcı sonra ayrıştırmak yığına lookahead sembolü, yeni bir ileri yönlü sembolü tarar vardiya ve tekrar dener.
Shift-azaltın ayrıştırıcıları türleri.
ayrıştırıcı tabloları üstteki ayrıştırmak yığını semboller ve ileri yönlü sembolü her türlü hukuki kombinasyonu için, bir sonraki adımın ne gösteriyor. Bu sonraki eylem benzersiz olmalıdır; vardiya veya azaltmak, ancak ikisini birden. (Bu açık olmanın ötesinde, dilbilgisi bazı başka sınırlamalar anlamına gelmektedir.) Tablo ayrıntıları shift-azaltmak ayrıştırıcıları farklı türleri arasında büyük farklılıklar göstermektedir.
Öncelik ayrıştırıcıları olarak, kolları sağ ucu ileri yönlü sembolü olduğu için üst yığın sembollerin öncelik düzeyi veya dilbilgisi gerginlik karşılaştırılarak bulunur. Yukarıdaki örnekte, "int" ve "id" ifadesi sınırlayıcı kıyasla iç dilbilgisi seviyelerine aittir;. Yani "int" ve "id" hem daha yüksek öncelik olarak kabul edilir; ardından zaman ve başka bir şey için azaltılmalıdır;. Öncelik ayrıştırıcıları, tutamacın sol ucunu bulma ve uygulamak doğru kural seçme farklı şekillerde her farklı çeşitleri vardır:
Öncelik ayrıştırıcıları onlar işleyebilir gramerlerde sınırlıdır. Karar verirken Onlar ayrıştırma yığının en görmezden. Onlar üstteki sembollerin sadece isimlerini değil, dilbilgisi, bu semboller şimdi nerede göründüğünü tam bağlam düşünün. Öncelik benzer görünümlü sembol kombinasyonları bağlamdan bağımsız, ancak bu kombinasyonlar meydana ayrıştırıldı ve dilbilgisi boyunca aynı şekilde kullanılması gerektiğini gerektirir.
LR ayrıştırıcılar daha birçok gramerler taşıma, shift-azaltmak ayrıştırma daha esnek bir formu vardır. LR ayrıştırıcılar her vardiya için bir devlet geçişi gerçekleştirerek, devlet makinesi gibi işlev veya eylemi azaltır. Bu mevcut durumu kaydırma eylemleri (aşağı) itilir bir yığın kullanır. Bu yığın daha sonra eylemlerini azaltmak tarafından (yukarı) uzattı. Bu mekanizma LR çözümleyici tüm deterministik bağlam-bağımsız gramerler, öncelik gramerler bir üst ele verir. LR ayrıştırıcı tamamen Canonical LR çözümleyici tarafından yürütülmektedir. Look-Ahead LR ve Basit LR ayrıştırıcılar önemli ölçüde bellek gereksinimlerini azalttı bunun basitleştirilmiş varyantları uygulamak. Son araştırmalar kanonik LR ayrıştırıcılar Knuth masa bina algoritması üzerinde önemli ölçüde azaltılmış tablo gereksinimleri ile uygulanabilir hangi yöntemleri belirlemiştir.
LR, LALR veya SLR olsun, temel durum makinesi aynıdır; Yalnızca tablolar farklıdır ve bu tabloları hemen hemen her zaman mekanik oluşturulur.
Bir devlet (genellikle, ama her zaman bir nonterminal sembolü temsil etmeyen) ve ileri yönlü uç sembolü göz önüne alındığında, (bundan böyle yapılandırmaları olarak anılacaktır) tam dört olası eylemler, HATA, SHIFT, AZALTMAK ve DUR vardır. Bir nokta varlığı, • Bir yapılandırmada noktanın sağında look-ahead sembolü ile geçerli ileriye dönük konumunu temsil (ve "her zaman" bir terminal sembolüne karşılık gelen), ve geçerli yığın durumu için Noktanın sol (ve hangi "genellikle" bir nonterminal sembolü karşılık gelir).
Kesinlikle yüksek-performans dahil olmak üzere, pratik nedenlerden dolayı, eylem tablosu genellikle, genellikle kodlanmış, bayt yönelik makinelerde etkin erişim için, tabii ki, dört, iki-bit semboller, bir bayt içine sıkıştırılmış iki-bitli sembollerin büyükçe bir dizi olarak uygulanan 00B = HATA, 01b = SHIFT, 10b olarak = (SHIFT özel bir durum olmaktan DUR) AZALTMAK ve 11b = DUR. Tüm dizi çoğunlukta HATA yapılandırmaları, SHIFT bir gramer tanımlı sayı ve yapılandırmaları AZALTMAK ve bir DUR yapılandırmasını içerir.
SHIFT ve AZALTMAK yapılandırmaları SHIFT-REDUCE çözümleyici temel tanımından, açıktır.
HATA sonra, yığının üstündeki devlet ve ileri yönlü uç sembol konusu dilbilgisi içinde "değil" bir yapılandırmayı temsil eder. Bu, daha sonra, bir hata kurtarma yordamını, belki de en basit biçimde, ilerleme, uç sembolü atmak ve sonraki terminal sembolü okumak, ama birçok diğer programlanmış eylemler yığını budama dahil, kesinlikle mümkündür çağırmak için bir fırsat temsil (<Program> sadece boş bir açıklamada oluşur <programı> • ⊥, ⊥ ve patolojik bir durumda, elde etmek mümkündür), ya da ilerleme, uç sembolü atarak "ve" yığınını budama.
DUR, ardından, yığının üstündeki devlet ve ileri yönlü terminali sembol konusu dilbilgisi içinde "dir" bir yapılandırma temsil eder ve programın sonunu temsil eder: ⊥ <Program> • ⊥, bu SHIFT imkansız olma Nihai ⊥ ötesinde.
Bazı durumlarda, yığın bilerek ⊥ • <program> ile ⊥, bu ilk ⊥ önce kabul edilmiş olduğu kabul edilir, bu, başlatılır, önceden yüklenmiş olabilir. Bu, daha sonra, programın başlangıcını temsil eden ve böylece ayrı bir BAŞLANGIÇ konfigürasyonuna sahip önler ve hangi kavramsal, • ⊥ <Program> ⊥.
⊥ <Program> (gramer programcı açıkça <program> içermiyordu ise) mekanik olarak dilbilgisi eklenen özel bir pseudo-nonterminal sembol olduğu gibi, mekanik dilbilgisi eklenen özel bir uçbirimsi simgesidir.
Açıkçası, böyle bir ayrıştırıcı tam bir (örtük) BAŞLANGIÇ konfigürasyon ve tek (açık) DUR konfigürasyonuna sahiptir, ancak can ve genellikle yapılandırmaları SHIFT yüzlerce var ve AZALTMAK yapar ve HATA konfigürasyonları belki binlerce.

Mutasyon testi
Mutasyon testi (ya da "mutasyon analizi" ya da "Program mutasyon") mevcut yazılım testlerinin kalitesini yeni yazılım testleri tasarlamak ve değerlendirmek için kullanılır. Mutasyon testi küçük şekillerde bir program değiştirme içerir. Her mutasyona uğramış versiyonu "mutant" denir ve testler mutant farklı orijinal sürümü davranışını neden olarak mutantlar algılar ve reddediyoruz. Bu "öldürme" mutant denir. Test suit onlar öldürmek mutantların yüzdesi ile ölçülür. Yeni testler ilave mutantlar öldürmek için tasarlanabilir. Mutantlar taklit tipik programlama (örneğin yanlış operatörü veya değişken adını kullanarak gibi) hata veya ya (örneğin sıfıra her ifadeyi bölünmesi gibi) değerli testlerin oluşturulmasını zorlamak olduğunu iyi tanımlanmış "mutasyon operatörleri" dayanmaktadır. Amaç test etkili testler geliştirmek veya program veya nadiren ya da hiç yürütme sırasında erişilen kod bölümlerde kullanılan test verileri zayıflıkları bulmanıza yardımcı olmaktır.
Bu yazının çoğu programı modifiye edildiği "programı mutasyon" hakkındadır. "Mutasyon analizi" nin daha genel bir tanım yazılım eserler sistematik değişiklikler yapmak için sözdizimsel yapılar üzerinde tanımlı iyi tanımlanmış kurallar kullanıyor. Mutasyon analizleri başka sorunlar uygulanmıştır, ancak genellikle test uygulanır. Yani "mutasyon testi" yeni yazılım testleri tasarlamak veya mevcut yazılım testleri değerlendirmek için mutasyon analizi kullanılarak olarak tanımlanır. Böylece, mutasyon analizi ve test programı mutasyon en yaygın olmasına rağmen, modeller, teknik özellikleri, veri tabanları, testler, XML ve yazılım eserler başka türlü tasarım için uygulanabilir.
Hedef.
Testler belirli bir yazılım sisteminin uygulanması doğruluğunu kontrol etmek için oluşturulabilir, ancak testlerin oluşturulması hala testleri doğru ve yeterince uygulanması kaynaklandığı ihtiyaçlarını karşılamak sorusunu ortaya çıkarmaktadır. (Bu teknolojik sorun kendisi adında bir derin felsefi sorunun bir örneğidir "Quis custodiet ipsos custodes?" ["Kim gardiyanlara koruyacak?"].) Bu bağlamda, mutasyon testi bulun ve zayıflıklarını ortaya çıkarmak için 1970'lerde öncülük Test suit. teori mutant etkilenen programın davranışı (genellikle çıkış) olmadan tanıtıldı eğer, bu da göstermektedir ki oldu (ölü kodu) idam asla mutasyona olmuştu kod veya test paketi hataları bulamadı olduğunu mutant ile temsil edilen. Bu herhangi bir ölçekte çalışması için, mutant bir sayıda, genellikle program kopyasını çok sayıda bir araya getirilmesi ve yürütülmesine neden büyük bir programın içine yerleştirilir. Için bir yol olarak mutasyon testi gider bu sorun yazılım test yöntemi olarak pratik kullanımı azalmış, ama nesne yönelimli programlama dilleri ve birim test çerçeveler artan kullanımı, birçok programlama dilleri için mutasyon test araçlarının yaratılmasına yol açmıştır Bir uygulamanın bireysel kısımlarının test edin.
Tarihsel bakış.
Mutasyon testi aslen 1971 yılında bir öğrenci olarak, Richard Lipton tarafından önerilen ve ilk geliştirilen ve DeMillo, Lipton ve Sayward tarafından yayımlandı. Bir mutasyon test aracının ilk uygulaması Yale Üniversitesi'nden 1980 yılında ("Mutasyon Analizi" başlıklı) doktora çalışmalarının bir parçası olarak Timothy Budd oldu.
Son zamanlarda, masif işlem gücü kullanılabilirliği ile, orada bilgisayar bilimi toplum içinde mutasyon analizi yeniden canlanması olmuştur ve iş XML gibi yönelimli programlama dilleri ve non-usul dilleri nesne mutasyon testi uygulayarak yöntemlerini belirlemek için yapılmıştır, SMV ve sonlu durum makineleri.
2004 yılında bir şirket Certess A.Ş. (Synopsys şimdi parçası) donanım doğrulama alanı içine ilkeleri birçok genişletilmiş çağırdı. Mutasyon analizi sadece üretilen çıktıda bir fark tespit beklediğini Oysa Certess testbenç bir denetleyicisi aslında fark algılar doğrulayarak bu uzanır. Aktivasyonu, yayılması ve algılama değerlendirilir: Bu eklenti doğrulama, yani her üç aşaması anlamına gelir. Onlar bu fonksiyonel yeterlilik çağırdı.
Tüylenme, mutasyon testi özel bir durumu olduğu düşünülebilir. Fuzzing olarak, mesaj veya veri veri işleme hataları veya farklılıkları yakalamak için mutasyona uğratılır (yazılım örnekleri iç ve aralarında hem de) iletişim arabirimleri içinde alış verişinde bulundular. Codenomicon (2001) ve Mu Dinamikleri (2005) iyice protokol uygulamaları egzersiz için monitörler ile tam durum bilgisi mutasyon testi platformuna tüylenme kavramları, gelişti.
Mutasyon testi genel bakış.
Mutasyon testi iki hipotez dayanmaktadır. İlk "Yetkili programcı" hipotezdir. Bu hipotez deneyimli programcılar tarafından tanıtıldı çoğu yazılım hataları, küçük sözdizimsel hataları nedeniyle olduğunu belirtmektedir. İkinci hipotez "birleştirme etkisi" denir. kavrama etkisi basit hatalar kaskad veya "çift" Diğer acil hataları oluşturmak için ileri sürülüyor.
Ince ve önemli faylar ayrıca bağlama etkisini desteklemek üst düzey mutantlar, ortaya çıkar. Yüksek mertebeden mutantlar birden fazla mutasyon ile mutantlar oluşturarak etkindir.
Mutasyon testi kaynak kodunun her geçerli parça için bir defada kaynak programda tek uygulamadan sonra mutasyon operatörleri bir dizi seçerek ve yapılır. programa bir mutasyon operatörü uygulanması sonucu, "mutant" olarak adlandırılır. Test paketi değişikliği tespit etmek mümkün değilse, o zaman mutant "öldürülen" olduğu söylenen (yani testlerden biri başarısız).
Örneğin, aşağıdaki C ++ kod parçası düşünün:
durum mutasyon operatörü codice_2 ile codice_1 değiştirmek ve aşağıdaki mutant üretecektir:
Test bu mutant öldürmek Şimdi, şu üç koşulun yerine getirilmesi gerekir:
Bu koşullar topluca "RIP modeli" olarak adlandırılır.
"Zayıf mutasyon testi" (ya da "zayıf mutasyon kapsama") Sadece birinci ve ikinci koşullar yerine olmasını gerektirir. "Güçlü mutasyon testi" Üç koşullar yerine gerektirir. Bu test paketi gerçekten sorunları yakalamak sağlar çünkü güçlü mutasyon, daha güçlüdür. Zayıf mutasyon kod kapsama yöntemleri yakından ilişkilidir. Bu test paketi, güçlü mutasyon testi daha zayıf mutasyon testi tatmin olmasını sağlamak için çok daha az işlem gücü gerektirir.
Ancak, bu mutant öldürebilecek bir test durumu bulmak mümkün değildir durumlar vardır. Elde edilen programın orijinal bir davranışsal eşdeğerdir. Bu tür mutantlar "eşdeğer mutantlar" olarak adlandırılır.
Eşdeğer mutantlar algılama mutasyon testi pratik kullanım için en büyük engellerden biridir. mutantlar eşdeğer olup olmadığını kontrol veya gerekli çaba bile küçük programlar için çok yüksek olabilir. (Tarafından sunulan) Eşdeğer Mutant Sorununu üstesinden gelmek için yaklaşımlar geniş bir yelpazede sistematik bir literatür taraması (22 makalelerinde) 17 İlgili teknikleri ve tekniklerin üç kategoride belirlenen: tespit (DEM); (SEM) düşündüren; ve eşdeğer mutant nesil (AEMG) kaçınılır. Deney özellikle genel ve JudyDiffOp stratejisinde Yüksek mertebeden Mutasyon Eşdeğer Mutant Sorununa umut verici bir yaklaşım sağlamak olduğunu belirtti.
Mutasyon operatörleri.
Birçok mutasyon operatörleri araştırmacılar tarafından incelenmiştir. İşte zorunlu diller için mutasyon operatörleri bazı örnekler:
mutantların mutantların mutasyon puanı = sayı öldürdü / toplam sayısı
Bu mutasyon operatörleri geleneksel mutasyon operatörleri denir.
Konteyner Operatörler "sınıf düzeyi" mutasyon operatörleri denir vb eşzamanlı inşaatları, konteyner gibi karmaşık nesneler, nesne yönelimli diller için mutasyon operatörleri de vardır. Örneğin muJava aracı gibi Erişim Değiştirici Değişim, Operatör Ekleme Cast Türü ve Tip Dökme Operatör Silme gibi çeşitli sınıf düzeyi mutasyon operatörleri sunuyor. Mutasyon operatörleri de programların güvenlik açığı testleri gerçekleştirmek için geliştirilmiştir
Fonksiyonel Özellikler (veya Test Cases) mutasyon.
Mutant arızalar oluşturulur ve modelin kodu bilgi içine enjekte edilir, geleneksel bir mutasyon testi aksine, doğrudan model özellikleri yerine bir model kodu yeni tanımlanan mutasyon operatörleri bir dizi uygulaması da araştırılmıştır. Model denetleyicisi tarafından ilk özelliklerin (veya test durumlarda) oluşturulur ve onaylanır mutant özellikleri ilk doğrulama işlemi sırasında kaçırılmış yeni özellikleri olarak kabul edilmelidir. Bu nedenle, özellikleri mevcut listesine bu yeni tespit özelliklere ekleyerek resmi doğrulama kapsama ölçüsünü artırır ve dolayısıyla daha güvenilir bir tasarıma yol açar.
